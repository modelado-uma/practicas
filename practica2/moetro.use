model metro

class Clock 
    attributes
        NOW : Integer init = 0 -- POSIX representation starting at 0
        resolution: Integer init = 1 
    operations
        tick() 
            begin
                self.NOW := self.NOW + self.resolution;
                for o in self.ao do 
                    o.tick()
            end;
        end
        post TimePasses: self.NOW = self.NOW@pre + self.resolution
    run (n: Integer)
        begin
            for i in Sequence{1..n} do
                self.tick()
            end 
        end
  constraints
    inv PositiveResolution: self.resolution > 0
end

abstract class ActiveObject -- real-time objects 
    operations
        tick() begin end 
end

association Time between 
    Clock [1] 
    ActiveObject [*] role ao ordered
end

class Segmento < ActiveObject
attributes
id : String

statemachines
    psm ViasOcupadas
    states
        s: initial
        Vacio       -- ninguna vía del segmento está ocupada
        Sentido1    -- solo hay tren en la vía de sentido 1
        Sentido2    -- solo hay tren en la vía de sentido 2
        Ambos       -- hay un tren en cada vía
    transitions
        s -> Vacio

        Vacio -> Sentido1 { [self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido1)] tick() }
        Vacio -> Sentido2 { [self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido2)] tick() }
        Vacio -> Ambos { [self.tren -> size() = 2 and self.tren -> exists(t | t.sentido = Sentidos::sentido1) and self.tren -> exists(t | t.sentido = Sentidos::sentido2)] tick() }
        Vacio -> Vacio { [not (self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido1)) and not (self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido2)) and not (self.tren -> size() = 2 and self.tren -> exists(t | t.sentido = Sentidos::sentido1) and self.tren -> exists(t | t.sentido = Sentidos::sentido2))] tick() }

        Sentido1 -> Vacio { [self.tren -> size() = 0] tick() }
        Sentido1 -> Sentido2 { [self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido2)] tick() }
        Sentido1 -> Ambos { [self.tren -> size() = 2 and self.tren -> exists(t | t.sentido = Sentidos::sentido1) and self.tren -> exists(t | t.sentido = Sentidos::sentido2)] tick() }
        Sentido1 -> Sentido1 { [not (self.tren -> size() = 0) and not (self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido2)) and not (self.tren -> size() = 2 and self.tren -> exists(t | t.sentido = Sentidos::sentido1) and self.tren -> exists(t | t.sentido = Sentidos::sentido2))] tick() }

        Sentido2 -> Vacio { [self.tren -> size() = 0] tick() }
        Sentido2 -> Sentido1 { [self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido1)] tick() }
        Sentido2 -> Ambos { [self.tren -> size() = 2 and self.tren -> exists(t | t.sentido = Sentidos::sentido1) and self.tren -> exists(t | t.sentido = Sentidos::sentido2)] tick() }
        Sentido2 -> Sentido2 { [not (self.tren -> size() = 0) and not (self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido1)) and not (self.tren -> size() = 2 and self.tren -> exists(t | t.sentido = Sentidos::sentido1) and self.tren -> exists(t | t.sentido = Sentidos::sentido2))] tick() }

        Ambos -> Vacio { [self.tren -> size() = 0] tick() }
        Ambos -> Sentido1 { [self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido1)] tick() }
        Ambos -> Sentido2 { [self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido2)] tick() }
        Ambos -> Ambos { [not (self.tren -> size() = 0) and not (self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido1)) and not (self.tren -> size() = 1 and self.tren -> exists(t | t.sentido = Sentidos::sentido2))] tick() }
    end
end

class Estacion < ActiveObject
attributes
id : String
nombre : String

statemachines
    psm Estacionamiento
    states
        s: initial
        Inicial     -- estado previo a la ejecución del primer tick
        Vacia       -- no hay trenes en la estación
        Ocupada     -- hay al menos un tren en la estación
    transitions
        s -> Inicial

        Inicial -> Vacia { [self.tren -> size() = 0] tick()}
        Inicial -> Ocupada { [self.tren -> size() > 0] tick()}

        Vacia -> Ocupada { [self.tren -> size() > 0] tick() }
        Vacia -> Vacia { [self.tren -> size() = 0] tick() }

        Ocupada -> Vacia { [self.tren -> size() = 0] tick() }
        Ocupada -> Ocupada { [self.tren -> size() > 0] tick() }        
    end
end

class Linea
attributes
id : String
nombre : String
end

enum Sentidos {sentido1, sentido2} 

class Tren < ActiveObject
attributes
id : String
sentido : Sentidos
ticksEspera : Integer init : 0
averiado : Boolean init : false

operations
    getPosicion() : String = if (self.estacion <> null) then ('El tren ' + self.id + ' se encuentra en la estacion ' + self.estacion.id + ' con nombre ' + self.estacion.nombre + '.') else ('El tren ' + self.id + ' se encuentra en el segmento ' + self.segmento.id + '.') endif;
    getSentido() : Sentidos = self.sentido;

    mover()
        begin
            -- Segmento siguiente
            declare s: Segmento;             
            
            if (self.sentido = Sentidos::sentido1)
            then s := self.estacion.segmentoS1 -> select(seg | (seg.linea -> exists(l | l = self.linea)) and (seg.tren -> exists(t | t.sentido = self.sentido) = false)) -> asOrderedSet() -> first();
            else if (self.sentido = Sentidos::sentido2)
                then s := self.estacion.segmentoS2 -> select(seg | (seg.linea -> exists(l | l = self.linea)) and (seg.tren -> exists(t | t.sentido = self.sentido) = false)) -> asOrderedSet() -> first();
                end;
            end;
            
            insert(self, s) into mueve; --Al moverse, el tren pasa a estar en el siguiente segmento
            delete(self.estacion, self) from alberga; --Al moverse, el tren deja de estar en la estación
            self.ticksEspera := 1; --Tarda 2 ticks en llegar de una estación a otra (ticksEspera = 1, ticksEspera = 0)
        end

        pre : (self.estacion <> null) --El tren debe estar en una estación para poder moverse
        pre : (self.segmento = null) --El tren no puede estar en un segmento para poder empezar a moverse
        pre : (self.ticksEspera = 0) --El tren no puede estar esperando en la estación para poder moverse; debe estar listo para salir
        pre : (((self.sentido = Sentidos::sentido1) and (self.estacion.segmentoS1 -> exists(seg | (seg.linea -> exists(l | l = self.linea)) and (seg.tren -> exists(t | t.sentido = self.sentido) = false))))
                or ((self.sentido = Sentidos::sentido2) and (self.estacion.segmentoS2 -> exists(seg | (seg.linea -> exists(l | l = self.linea)) and (seg.tren -> exists(t | t.sentido = self.sentido) = false)))))
                --El próximo segmento debe tener el mismo sentido y línea que el tren y el sentido que va a ocupar el tren debe estar vacío

        post : (self.estacion = null) --El tren ha dejado la estación
        post : (self.segmento <> null) --El tren ha pasado a un segmento
    
    parar()
        begin            
            --Estación siguiente:
            declare e: Estacion;

            if (self.sentido = Sentidos::sentido1)
            then e := self.segmento.estacionS2;                
            else if (self.sentido = Sentidos::sentido2) 
                then e := self.segmento.estacionS1;                
                end;
            end;

            --Cambiar sentido del tren cuando la estación siguiente es extremo de una línea:
            if (e.linea -> exists(l | l = self.linea))            
            then if (self.sentido = Sentidos::sentido1)
                then self.sentido := Sentidos::sentido2;                    
                else if (self.sentido = Sentidos::sentido2)
                    then self.sentido := Sentidos::sentido1;                    
                    end;
                end;                
            end;

            insert(e, self) into alberga; --Al parar, el tren pasa a estar en la siguiente estación
            delete(self, self.segmento) from mueve; --Al moverse, el tren deja de estar en el segmento

            if (self.averiado = true)
                then self.ticksEspera := -1; --Representa infinito, es decir, tarda ticks indefinidos hasta ser reparado
                else self.ticksEspera := 0; --Tarda 1 tick en parar en la estación (ticksEspera = 0)
            end;
        end
        pre : (self.segmento <> null) --El tren debe estar en un segmento para poder parar
        pre : (self.estacion = null) --El tren no puede estar en una estación para poder parar
        pre : (self.ticksEspera = 0) --El tren no puede estar esperando a llegar a la estación para poder pararse; debe estar listo para parar
        pre : (((self.sentido = Sentidos::sentido1) and (self.segmento.estacionS2 <> null))
                or ((self.sentido = Sentidos::sentido2) and (self.segmento.estacionS1 <> null)))
                --La próxima estación debe estar conectada al segmento actual en el sentido contrario al tren                

        post : (self.segmento = null) --El tren ha dejado el segmento
        post : (self.estacion <> null) --El tren ha pasado a una estación

    tick()
        begin
            if (self.ticksEspera > 0)
            then 
                self.ticksEspera := self.ticksEspera - 1;
                        
            else if (self.ticksEspera = 0)
                then 
                    if (self.averiado = false and self.estacion <> null)
                    then if ((((self.sentido = Sentidos::sentido1) and (self.estacion.segmentoS1 -> exists(seg | (seg.linea -> exists(l | l = self.linea)) and (seg.tren -> exists(t | t.sentido = self.sentido) = false))))
                            or ((self.sentido = Sentidos::sentido2) and (self.estacion.segmentoS2 -> exists(seg | (seg.linea -> exists(l | l = self.linea)) and (seg.tren -> exists(t | t.sentido = self.sentido) = false))))))
                        then self.mover();
                        end;
                    else if (self.averiado = false and self.segmento <> null)
                        then self.parar();
                        else if (self.averiado = true and self.estacion <> null)
                            then self.ticksEspera := -1;
                            else if (self.averiado = true and self.segmento <> null)
                                then self.parar();
                                end;
                            end;
                        end;
                    end;
                end;
            end;

------ APARTADO e)

            if ((self.clock.NOW = 3 and self.id = 'T-5') or (self.clock.NOW = 8 and self.id = 'T-4'))
                then self.averiado := true;
            end;

            if ((self.clock.NOW = 6 and self.id = 'T-5') or (self.clock.NOW = 12 and self.id = 'T-4'))
            then 
                self.averiado := false;
                self.ticksEspera := 0;
            end;
        end

statemachines
    psm Transito
    states
        s: initial
        Parado      -- en buen estado, en estación
        Moviendo    -- en buen estado, en movimiento
        Averiado    -- en mal estado, en movimiento
        Arreglando  -- en mal estado, en estación
    transitions
        s -> Parado
        Parado -> Moviendo { [self.ticksEspera = 0 and self.averiado = false and self.estacion <> null and (((self.sentido = Sentidos::sentido1) and (self.estacion.segmentoS1 -> exists(seg | (seg.linea -> exists(l | l = self.linea)) and (seg.tren -> exists(t | t.sentido = self.sentido) = false)))) or ((self.sentido = Sentidos::sentido2) and (self.estacion.segmentoS2 -> exists(seg | (seg.linea -> exists(l | l = self.linea)) and (seg.tren -> exists(t | t.sentido = self.sentido) = false))))) and not ((self.clock.NOW = 3 and self.id = 'T-5') or (self.clock.NOW = 8 and self.id = 'T-4'))] tick() }
        Parado -> Arreglando { [(self.clock.NOW = 3 and self.id = 'T-5') or (self.clock.NOW = 8 and self.id = 'T-4')] tick() }
        Parado -> Parado { [not (self.ticksEspera = 0 and self.averiado = false and self.estacion <> null and (((self.sentido = Sentidos::sentido1) and (self.estacion.segmentoS1 -> exists(seg | (seg.linea -> exists(l | l = self.linea)) and (seg.tren -> exists(t | t.sentido = self.sentido) = false)))) or ((self.sentido = Sentidos::sentido2) and (self.estacion.segmentoS2 -> exists(seg | (seg.linea -> exists(l | l = self.linea)) and (seg.tren -> exists(t | t.sentido = self.sentido) = false))))) and not ((self.clock.NOW = 3 and self.id = 'T-5') or (self.clock.NOW = 8 and self.id = 'T-4'))) and not ((self.clock.NOW = 3 and self.id = 'T-5') or (self.clock.NOW = 8 and self.id = 'T-4'))] tick() }

        Moviendo -> Parado { [self.ticksEspera = 0 and self.averiado = false and self.segmento <> null and not ((self.clock.NOW = 3 and self.id = 'T-5') or (self.clock.NOW = 8 and self.id = 'T-4'))] tick() }
        Moviendo -> Averiado { [((self.clock.NOW = 3 and self.id = 'T-5') or (self.clock.NOW = 8 and self.id = 'T-4')) and not (self.ticksEspera = 0 and self.averiado = false and self.segmento <> null)] tick() }
        Moviendo -> Arreglando { [(self.ticksEspera = 0 and self.averiado = false and self.segmento <> null) and ((self.clock.NOW = 3 and self.id = 'T-5') or (self.clock.NOW = 8 and self.id = 'T-4'))] tick() }
        Moviendo -> Moviendo { [not (self.ticksEspera = 0 and self.averiado = false and self.segmento <> null and not ((self.clock.NOW = 3 and self.id = 'T-5') or (self.clock.NOW = 8 and self.id = 'T-4'))) and not (((self.clock.NOW = 3 and self.id = 'T-5') or (self.clock.NOW = 8 and self.id = 'T-4')) and not (self.ticksEspera = 0 and self.averiado = false and self.segmento <> null)) and not ((self.ticksEspera = 0 and self.averiado = false and self.segmento <> null) and ((self.clock.NOW = 3 and self.id = 'T-5') or (self.clock.NOW = 8 and self.id = 'T-4')))] tick() }

        Averiado -> Arreglando { [self.ticksEspera = 0 and self.averiado = true and self.segmento <> null] tick() }
        Averiado -> Averiado { [not (self.ticksEspera = 0 and self.averiado = true and self.segmento <> null)] tick() }
        
        Arreglando -> Parado { [(self.clock.NOW = 6 and self.id = 'T-5') or (self.clock.NOW = 12 and self.id = 'T-4')] tick() }
        Arreglando -> Arreglando { [not ((self.clock.NOW = 6 and self.id = 'T-5') or (self.clock.NOW = 12 and self.id = 'T-4'))] tick() }
    end
end


aggregation segmentoLinea between
Linea [1..*] role linea
Segmento [1..*] role segmento
end

association circula between
Linea [1] role linea
Tren [1..*] role tren
end

association alberga between
Estacion [0..1] role estacion
Tren [*] role tren
end

association conectaS1 between
Estacion [1] role estacionS1
Segmento [1..*] role segmentoS1
end

association conectaS2 between
Estacion [1] role estacionS2
Segmento [1..*] role segmentoS2
end

association mueve between
Tren [0..2] role tren
Segmento [0..1] role segmento
end

association extremo between
Estacion [2] role estacion
Linea [*] role linea
end


constraints

context Segmento    
    inv lineasDistintas : Segmento.allInstances() -> forAll(s | (self.id = s.id) or
                                                            (self.id <> s.id and (((self.estacionS1 <> s.estacionS1 and self.estacionS1 <> s.estacionS2) or (self.estacionS2 <> s.estacionS1 and self.estacionS2 <> s.estacionS2)) 
                                                            or ((self.estacionS1 = s.estacionS1 or self.estacionS1 = s.estacionS2) and (self.estacionS2 = s.estacionS1 or self.estacionS2 = s.estacionS2) and (self.linea <> s.linea)))))