model Practica2

enum EstadoCoche {
    ESTACIONADO
    ENVIAJE
    ENTALLER
}

enum TipoRevision {
    MANTENIMIENTO
    REPARACION
}


-- class Clock 
--     attributes
--         NOW : Integer init = 0 -- POSIX representation starting at 0
--         resolution: Integer init = 1 
--     operations
--         tick() 
--             begin
--                 self.NOW := self.NOW + self.resolution;
--                 for o in self.ao do 
--                     o.tick()
--             end;
--         end
--         post TimePasses: self.NOW = self.NOW@pre + self.resolution
--     run (n: Integer)
--         begin
--             for i in Sequence{1..n} do
--                 self.tick()
--             end 
--         end
--   constraints
--     inv PositiveResolution: self.resolution > 0



class Coche
attributes
garantia: Boolean
fechaMatriculacion: Integer
estado: EstadoCoche
numKm: Integer
derive:
    self.viajeQueHaceCoche->collect(viaje | viaje.distancia)->sum()
end

class Ciudad
end

class Viaje
attributes
fechaInicio: Integer
fechaFin: Integer
distancia: Integer
end

abstract class Taller
end

class TallerOficial < Taller
attributes
garantia: Integer
end

class TallerNoOficial < Taller
end

class Revision
attributes
fechaInicio: Integer
fechaFin: Integer
tipoRevision: 
end


----------Asociaciones---------- 

association estacionadoEn between
    Ciudad[0..1] role ciudadCocheEstacionado
    Coche[*] role esta cocheEstacionadoEnCiudad
end

association cocheHaceViaje between
    Coche[1] role cocheEnElViaje
    Viaje[*] role viajeQueHaceCoche
end

association contieneTallerNoOficial between
    Ciudad[*] role ciudadconTallerNoOficial
    NoOficial[*] role tallerNoOficialEstaEnCiudad
end

association tallerOficialCiudad between
    Ciudad[*] role ciudadConTallerOficial
    Oficial[1] role tallerOficialEstaEnCiudad
end

association cocheEnRevision between
    Coche[1] role cocheHaciendoRevision
    Revision[*] role revisionDelCoche
end

association tallerRevision between
    Taller[1] role tallerQueRevisa
    Revision[*] role RevisionRealizadaPorTaller
end

association ciudadDestinoViaje between
    Ciudad[1] role 
    Viaje[*] role viajaA
end

association ciudadOrigenViaje between
    Ciudad[1] role ciudadOrigenDelViaje
    Viaje[*] role viajaDesde
end

--Invariantes

constraints

context Viaje 
--cada ciudad debe estar al menos a 5 kilómetros de distancia de otra. 
inv distanciaMinimaEntreCiudades:
    self.distancia >= 5
--la ciudad de origen y destino de un viaje deben ser distintas
inv ciudadOrigenYDestinoDistintas:
    self.ciudadOrigenDelViaje <> self.ciudadDestinoDelViaje


context Coche
inv revisionesDeCocheNoSePisan:
    self.revisionDelCoche -> forAll (r1 | self.revisionDelCoche -> forAll (r2 | r1 <> r2 && r1.fechaFin < r2.fechaInicio || r1.fechaInicio > r2.fechaFin))
  
  
 context cocheEnRevision
--fecha de revision del coche tiene que ser posterior a fecha de revision
inv fechaRevisionPOSTFechaMatriculacion:
    self.revisionDelCoche.fechaInicio > self.cocheHaciendoRevision.fechaMatriculacion

--Si un coche está siendo sometido a revisión en un taller, el coche se debe encontrar
-- en la ciudad de ese mismo taller
inv cocheEstaMismaCiudadTallerCuandoEnRevision:
    if self.estado = EstadoCoche-#ENTALLER implies(
        if self.revisionDelCoche.tallerQueRevisa.oclIsTypeOf(TallerOficial) then
            self.ciudadCocheEstacionado = self.revisionDelCoche.tallerQueRevisa.ciudadConTallerOficial
        else
            self.ciudadCocheEstacionado = self.revisionDelCoche.tallerQueRevisa.ciudadConTallerNoOficial
        endif
    )


inv self.estado = EstadoCoche-#ENVIAJE implies self.viajeQueHaceCoche -> exists(viaje | viaje.fechaFin = null)

inv cuidadDeDestinoAnteriorCuidadDeOrigenSiguiente:
  self.viajeQueHaceCoche -> forAll( v | self.viajeQueHaceCoche -> select(v2 | v2.fechaFin < v.fechaInicio) -> sortedBy(fechaFin) -> last().ciudadDestino = v.ciudadOrigen)) 

--   lista = (x1,x2,x3,x4) ==> for i in range(lista)
--   i.ciudaddestino == i+1.ciudadOrigen
--   x3 -> (x1,x2) -> sort -> last() -> x2

 
